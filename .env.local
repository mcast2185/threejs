
# // import './style.css'
# // import * as THREE from 'three'
# // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'
# // import * as dat from 'dat.gui'


# // // Debug
# // const gui = new dat.GUI()

# // // Canvas
# // const canvas = document.querySelector('canvas.webgl')

# // // Scene
# // const scene = new THREE.Scene()

# // // Objects
# // let geometry;
# // // let geometry = window.screenX < window.screenX / 2 ? new THREE.SphereGeometry(.55, 22, 22) : window.screenX > window.screenX / 2 ? new THREE.SphereGeometry(.75, 22, 22) : new THREE.SphereGeometry(.65, 22, 22);
# // // const geometry = new THREE.TorusGeometry( .7, .2, 16, 100 );

# // const particlesGeometry = new THREE.BufferGeometry;
# // const particlesCnt = 3000;

# // const posArray = new Float32Array(particlesCnt * 3);
# // for (let i = 0; i < particlesCnt * 3; i++) {
# //     let x = (Math.random() - 0.5) * 3.1;
# //     let y = (Math.random() - 0.5) * 3.1;
# //     let z = (Math.random() - 0.5) * 3.1;
# //     posArray[i] = x, y, z;

# // };


# // particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

# // // Materials
# // const material = new THREE.PointsMaterial({
# //     size: .0045
# // })

# // const particleMaterial = new THREE.PointsMaterial({
# //     size: .0045,
# //     map: crossOriginIsolated,
# //     // transparent: true,

# // })


# // // Mesh
# // const sphere = new THREE.Points(geometry, material)
# // const particlesMesh = new THREE.Points(particlesGeometry, particleMaterial)
# // scene.add(sphere, particlesMesh)


# // // Lights

# // const pointLight = new THREE.PointLight(0xffffff, 0.1)
# // pointLight.position.x = 2
# // pointLight.position.y = 3
# // pointLight.position.z = 4
# // scene.add(pointLight)

# // /**
# //  * Sizes
# //  */
# // const sizes = {
# //     width: window.innerWidth,
# //     height: window.innerHeight
# // }

# // window.addEventListener('resize', () => {
# //     // Update sizes
# //     sizes.width = window.innerWidth
# //     sizes.height = window.innerHeight

# //     // Update camera    
# //     camera.aspect = sizes.width / sizes.height
# //     // camera.aspect = sizes.width / sizes.height
# //     camera.updateProjectionMatrix()

# //     // Update renderer
# //     renderer.setSize(innerWidth, innerHeight)
# //     renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
# // })

# // /**
# //  * Camera
# //  */
# // // Base camera
# // const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)
# // camera.position.x = 0
# // camera.position.y = 0
# // camera.position.z = 2

# // camera.position.set(0, 0, 10);
# // camera.lookAt(scene.position)

# // const rendererObj = new THREE.WebGLRenderer({ antialias: true })
# // rendererObj.setSize(sizes.width, sizes.height)
# // rendererObj.setAnimationLoop(animationLoop)
# // document.body.appendChild(rendererObj.domElement)
# // scene.add(camera)

# // const canvasElement = document.createElement("CANVAS")
# // canvasElement.width = 64;
# // canvasElement.height = 64;

# // const context = canvasElement.getContext('2d')
# // context.filter = 'blur(6px)',
# //     context.fillStyle = 'dimgray',
# //     context.fillReact(32 - 4, 32 - 4, 9, 9)

# // const texture = new THREE.CanvasTexture(canvasElement)


# // function animationLoop(t) {
# //     for (var i = 0; i < n; i++) {
# //         var time = t / 500 + i / 80,
# //             sin = THREE.MathUtils.clamp(1.1 * Math.sin(time), -1, 1);
# //         stars[i].position.z = -200 + 150 * sin;
# //     }

# //     renderer.render(scene, camera);
# // }
# // // Controls
# // const controls = new OrbitControls(camera, canvas)
# // controls.enableDamping = true

# // /**
# //  * Renderer
# //  */
# // const renderer = new THREE.WebGLRenderer({
# //     canvas: canvas
# // })
# // renderer.setSize(sizes.width, sizes.height)
# // renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
# // renderer.setClearColor(new THREE.Color('#161b1c'), 1)

# // /**
# //  * Animate
# //  */

# // const clock = new THREE.Clock()

# // const tick = () => {

# //     const elapsedTime = clock.getElapsedTime()

# //     // Update objects
# //     //  bg-rotate
# //     // particlesMesh.rotation.z = .03 * elapsedTime
# //     sphere.rotation.y = .5 * elapsedTime

# //     // Update Orbital Controls
# //     controls.update()

# //     // Render
# //     renderer.render(scene, camera)

# //     // Call tick again on the next frame
# //     window.requestAnimationFrame(tick)
# // }

# // tick()